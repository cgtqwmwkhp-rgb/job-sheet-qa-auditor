# AZURE CONTAINER APPS DEPLOYMENT WORKFLOW
# Builds, pushes to ACR, and deploys to Azure Container Apps.
#
# Flow:
#   1. Build & push to ACR (on push to main or manual dispatch)
#   2. Deploy to staging automatically
#   3. Run release verification on staging
#   4. Manual approval gate for production
#   5. Deploy to production (manual trigger only)
#
# Required Secrets:
#   AZURE_CREDENTIALS              - Azure Service Principal JSON
#   ACR_LOGIN_SERVER               - e.g., myregistry.azurecr.io
#   ACR_USERNAME                   - ACR username
#   ACR_PASSWORD                   - ACR password
#   STAGING_CONTAINER_APP          - Staging Container App name
#   PRODUCTION_CONTAINER_APP       - Production Container App name
#   AZURE_RESOURCE_GROUP           - Azure Resource Group name
#   DATABASE_URL                   - MySQL connection string
#   AZURE_STORAGE_CONNECTION_STRING - Azure Blob Storage connection string
#
# Environment Variables (set in GitHub Environment):
#   STAGING_URL                    - Staging app URL (e.g., https://app-staging.azurecontainerapps.io)
#   PRODUCTION_URL                 - Production app URL (e.g., https://app-prod.azurecontainerapps.io)
#   STORAGE_PROVIDER               - 'azure' for Azure Blob, 'local' for disk
#   AZURE_STORAGE_CONTAINER_NAME   - Blob container name
#   ENABLE_PURGE_EXECUTION         - 'false' for staging
#   ENABLE_SCHEDULER               - 'false' for staging
#
# Optional Secrets:
#   MISTRAL_API_KEY                - For OCR functionality
#   GEMINI_API_KEY                 - For AI insights

name: Azure Deploy

on:
  # Automatic deployment on push to main
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/ci*.yml'
      - '.github/workflows/parity*.yml'

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      staging_url_override:
        description: 'Staging URL override (leave empty to auto-detect)'
        required: false
        type: string
      production_url_override:
        description: 'Production URL override (leave empty to auto-detect)'
        required: false
        type: string
      skip_verification:
        description: 'Skip release verification (NOT recommended)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: "22"
  IMAGE_NAME: job-sheet-qa-auditor

jobs:
  # Build and Push to ACR
  build-and-push:
    name: Build & Push to ACR
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.image_tag }}
      short_sha: ${{ steps.set_tag.outputs.short_sha }}
      git_sha: ${{ github.sha }}

    steps:
      - name: Log context
        run: |
          echo "  Azure Container Apps Deployment"
          echo "  SHA:    ${{ github.sha }}"
          echo "  REF:    ${{ github.ref }}"
          echo "  EVENT:  ${{ github.event_name }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run tests
        run: pnpm test

      - name: Build application
        run: pnpm build

      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Set image tag
        id: set_tag
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "Using image tag: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}"

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            GIT_SHA=${{ github.sha }}
            PLATFORM_VERSION=${{ github.ref_name }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    needs: build-and-push
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging') }}
    environment:
      name: staging
      url: ${{ steps.get_url.outputs.app_url }}
    outputs:
      app_url: ${{ steps.get_url.outputs.app_url }}

    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure ACR credentials on Container App
        run: |
          echo "Configuring ACR registry credentials..."
          az containerapp registry set \
            --name "${{ secrets.STAGING_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --server "${{ secrets.ACR_LOGIN_SERVER }}" \
            --username "${{ secrets.ACR_USERNAME }}" \
            --password "${{ secrets.ACR_PASSWORD }}"

      - name: Deploy to Container App (Staging)
        id: deploy
        run: |
          echo "Deploying image: ${{ needs.build-and-push.outputs.image_tag }}"
          az containerapp update \
            --name "${{ secrets.STAGING_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --image "${{ needs.build-and-push.outputs.image_tag }}"

      - name: Set environment variables
        run: |
          az containerapp update \
            --name "${{ secrets.STAGING_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --set-env-vars \
              NODE_ENV=production \
              APP_ENV=staging \
              GIT_SHA="${{ github.sha }}" \
              PLATFORM_VERSION="${{ github.ref_name }}" \
              BUILD_TIME="${{ github.event.head_commit.timestamp }}" \
              STORAGE_PROVIDER="${{ vars.STORAGE_PROVIDER || 'azure' }}" \
              AZURE_STORAGE_CONTAINER_NAME="${{ vars.AZURE_STORAGE_CONTAINER_NAME || 'jobsheets-staging' }}" \
              ENABLE_PURGE_EXECUTION="${{ vars.ENABLE_PURGE_EXECUTION || 'false' }}" \
              ENABLE_SCHEDULER="${{ vars.ENABLE_SCHEDULER || 'false' }}"

      - name: Set secrets as environment variables
        run: |
          # Set storage connection string as a secret env var
          if [ -n "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" ]; then
            az containerapp secret set \
              --name "${{ secrets.STAGING_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --secrets "azure-storage-connection-string=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}"
            
            az containerapp update \
              --name "${{ secrets.STAGING_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "AZURE_STORAGE_CONNECTION_STRING=secretref:azure-storage-connection-string"
          fi
          
          # Set database URL as a secret env var
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            az containerapp secret set \
              --name "${{ secrets.STAGING_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --secrets "database-url=${{ secrets.DATABASE_URL }}"
            
            az containerapp update \
              --name "${{ secrets.STAGING_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "DATABASE_URL=secretref:database-url"
          fi

      - name: Get staging URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name "${{ secrets.STAGING_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query properties.configuration.ingress.fqdn -o tsv)
          APP_URL="https://${FQDN}"
          echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT
          echo "Staging URL: ${APP_URL}"

      - name: Wait for deployment
        run: |
          echo "Waiting 90 seconds for deployment to stabilize..."
          sleep 90

      - name: Smoke test staging
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Testing: $APP_URL"
          
          # Test healthz (required)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/healthz" --max-time 30)
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "âŒ /healthz returned $HTTP_CODE"
            curl -sS "$APP_URL/healthz" || true
            exit 1
          fi
          echo "âœ… /healthz returned 200"
          
          # Test readyz (required for full health)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/readyz" --max-time 30)
          READYZ_BODY=$(curl -sS "$APP_URL/readyz" --max-time 30)
          echo "ðŸ“‹ /readyz response: $READYZ_BODY"
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "âš ï¸ /readyz returned $HTTP_CODE (storage may not be configured)"
            # Don't fail on readyz for staging - storage config may be pending
          else
            echo "âœ… /readyz returned 200"
          fi
          
          # Test metrics (required per ADR-003)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/metrics" --max-time 30)
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "âŒ /metrics returned $HTTP_CODE"
            exit 1
          fi
          # Verify it's Prometheus format, not HTML
          METRICS_SAMPLE=$(curl -sS "$APP_URL/metrics" --max-time 30 | head -5)
          if echo "$METRICS_SAMPLE" | grep -q "^# HELP"; then
            echo "âœ… /metrics returned 200 with Prometheus format"
          else
            echo "âŒ /metrics returned HTML instead of Prometheus format"
            exit 1
          fi

  # Verify Staging (Full Release Verification)
  verify-staging:
    name: Verify Staging
    needs: [build-and-push, deploy-staging]
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_verification }}
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get staging URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name "${{ secrets.STAGING_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query properties.configuration.ingress.fqdn -o tsv)
          echo "staging_url=https://${FQDN}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Resolved staging URL: https://${FQDN}"

      - name: Run release verification
        env:
          STAGING_URL: ${{ steps.get_url.outputs.staging_url }}
          EXPECTED_SHA: ${{ github.sha }}
        run: |
          if [ -z "$STAGING_URL" ]; then
            echo "âŒ ERROR: Could not resolve staging URL from Azure"
            exit 1
          fi
          echo "ðŸ”— Using STAGING_URL: $STAGING_URL"
          
          chmod +x scripts/release/smoke-check.sh
          chmod +x scripts/release/monitor-snapshot.sh
          
          # Run smoke checks (soft mode for staging)
          ./scripts/release/smoke-check.sh "$STAGING_URL" "$EXPECTED_SHA" "soft"
          
          # Run monitoring snapshot
          ENVIRONMENT=staging HEALTH_ONLY=false \
            ./scripts/release/monitor-snapshot.sh "$STAGING_URL" "soft" "false"

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-verification-${{ github.run_id }}
          path: logs/release/
          retention-days: 30

  # Deploy to Production (Manual Trigger Only)
  deploy-production:
    name: Deploy to Production
    needs: [build-and-push, verify-staging]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.environment == 'production' }}
    environment:
      name: production
      url: ${{ steps.get_url.outputs.app_url }}
    outputs:
      app_url: ${{ steps.get_url.outputs.app_url }}

    steps:
      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure ACR credentials on Container App
        run: |
          echo "Configuring ACR registry credentials..."
          az containerapp registry set \
            --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --server "${{ secrets.ACR_LOGIN_SERVER }}" \
            --username "${{ secrets.ACR_USERNAME }}" \
            --password "${{ secrets.ACR_PASSWORD }}"

      - name: Deploy to Container App (Production)
        id: deploy
        run: |
          echo "Deploying image: ${{ needs.build-and-push.outputs.image_tag }}"
          az containerapp update \
            --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --image "${{ needs.build-and-push.outputs.image_tag }}"

      - name: Set environment variables
        run: |
          az containerapp update \
            --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --set-env-vars \
              NODE_ENV=production \
              APP_ENV=production \
              GIT_SHA="${{ github.sha }}" \
              PLATFORM_VERSION="${{ github.ref_name }}" \
              BUILD_TIME="${{ github.event.head_commit.timestamp }}" \
              STORAGE_PROVIDER="${{ vars.STORAGE_PROVIDER || 'azure' }}" \
              AZURE_STORAGE_CONTAINER_NAME="${{ vars.AZURE_STORAGE_CONTAINER_NAME || 'jobsheets' }}" \
              ENABLE_PURGE_EXECUTION="${{ vars.ENABLE_PURGE_EXECUTION || 'false' }}" \
              ENABLE_SCHEDULER="${{ vars.ENABLE_SCHEDULER || 'false' }}"

      - name: Set secrets as environment variables
        run: |
          # Set storage connection string as a secret env var
          if [ -n "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" ]; then
            az containerapp secret set \
              --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --secrets "azure-storage-connection-string=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}"
            
            az containerapp update \
              --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "AZURE_STORAGE_CONNECTION_STRING=secretref:azure-storage-connection-string"
          fi
          
          # Set database URL as a secret env var
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            az containerapp secret set \
              --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --secrets "database-url=${{ secrets.DATABASE_URL }}"
            
            az containerapp update \
              --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
              --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "DATABASE_URL=secretref:database-url"
          fi

      - name: Get production URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query properties.configuration.ingress.fqdn -o tsv)
          APP_URL="https://${FQDN}"
          echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT
          echo "Production URL: ${APP_URL}"

      - name: Wait for deployment
        run: |
          echo "Waiting 90 seconds for deployment to stabilize..."
          sleep 90

      - name: Smoke test production (STRICT)
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Testing: $APP_URL (STRICT mode - all checks must pass)"
          
          # Test all endpoints - ALL must pass for production
          for ENDPOINT in healthz readyz metrics; do
            HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/$ENDPOINT" --max-time 30)
            if [[ "$HTTP_CODE" != "200" ]]; then
              echo "âŒ /$ENDPOINT returned $HTTP_CODE"
              curl -sS "$APP_URL/$ENDPOINT" || true
              exit 1
            fi
            echo "âœ… /$ENDPOINT returned 200"
          done
          
          # Verify metrics is Prometheus format (ADR-003)
          METRICS_SAMPLE=$(curl -sS "$APP_URL/metrics" --max-time 30 | head -5)
          if ! echo "$METRICS_SAMPLE" | grep -q "^# HELP"; then
            echo "âŒ /metrics returned HTML instead of Prometheus format"
            exit 1
          fi
          echo "âœ… /metrics is valid Prometheus format"

  # Verify Production (Strict Mode)
  verify-production:
    name: Verify Production
    needs: [build-and-push, deploy-production]
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.environment == 'production' && !inputs.skip_verification }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get production URL
        id: get_url
        run: |
          FQDN=$(az containerapp show \
            --name "${{ secrets.PRODUCTION_CONTAINER_APP }}" \
            --resource-group "${{ secrets.AZURE_RESOURCE_GROUP }}" \
            --query properties.configuration.ingress.fqdn -o tsv)
          echo "production_url=https://${FQDN}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Resolved production URL: https://${FQDN}"

      - name: Run release verification (STRICT)
        env:
          PRODUCTION_URL: ${{ steps.get_url.outputs.production_url }}
          EXPECTED_SHA: ${{ github.sha }}
        run: |
          if [ -z "$PRODUCTION_URL" ]; then
            echo "âŒ ERROR: Could not resolve production URL from Azure"
            exit 1
          fi
          echo "ðŸ”— Using PRODUCTION_URL: $PRODUCTION_URL"
          
          chmod +x scripts/release/smoke-check.sh
          chmod +x scripts/release/monitor-snapshot.sh
          
          # Run smoke checks (STRICT mode for production)
          ./scripts/release/smoke-check.sh "$PRODUCTION_URL" "$EXPECTED_SHA" "strict"
          
          # Run monitoring snapshot (STRICT mode, metrics REQUIRED)
          ENVIRONMENT=production HEALTH_ONLY=false \
            ./scripts/release/monitor-snapshot.sh "$PRODUCTION_URL" "strict" "false"

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-verification-${{ github.run_id }}
          path: logs/release/
          retention-days: 30

      - name: Generate deployment summary
        run: |
          {
            echo "# Production Deployment Complete âœ…"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            echo "| SHA | ${{ github.sha }} |"
            echo "| URL | ${{ needs.deploy-production.outputs.app_url }} |"
            echo "| Verification | STRICT mode PASSED |"
          } >> "$GITHUB_STEP_SUMMARY"

