# AZURE CONTAINER APPS DEPLOYMENT WORKFLOW
# Builds, pushes to ACR, and deploys to Azure Container Apps.
#
# Flow:
#   1. Build & push to ACR (on push to main or manual dispatch)
#   2. Deploy to staging automatically
#   3. Run release verification on staging
#   4. Manual approval gate for production
#   5. Deploy to production (manual trigger only)
#
# ENVIRONMENT-SCOPED VARIABLES (set in GitHub Environments):
#   Each environment (staging/production) must have these vars set:
#   - AZURE_RESOURCE_GROUP     - Environment-specific Azure Resource Group
#   - CONTAINER_APP_NAME       - Environment-specific Container App name
#   - STAGING_URL / PRODUCTION_URL - Environment-specific app URL
#
# SHARED REPOSITORY SECRETS (used by all environments):
#   - AZURE_CREDENTIALS        - Azure Service Principal JSON
#   - ACR_LOGIN_SERVER         - e.g., myregistry.azurecr.io
#   - ACR_USERNAME             - ACR username
#   - ACR_PASSWORD             - ACR password
#   - DATABASE_URL             - Database connection string (optional)
#   - AZURE_STORAGE_CONNECTION_STRING - Blob Storage connection (optional)
#
# DEPRECATED (DO NOT USE - will fail governance checks):
#   - secrets.AZURE_RESOURCE_GROUP
#   - secrets.STAGING_CONTAINER_APP
#   - secrets.PRODUCTION_CONTAINER_APP
#
# See: docs/operations/environment-contract.json for full specification

name: Azure Deploy

on:
  # Automatic deployment on push to main
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - '.github/workflows/ci*.yml'
      - '.github/workflows/parity*.yml'

  # Manual deployment trigger
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - staging
          - production
        default: staging
      skip_verification:
        description: 'Skip release verification (NOT recommended)'
        required: false
        type: boolean
        default: false

env:
  NODE_VERSION: "22"
  IMAGE_NAME: job-sheet-qa-auditor

jobs:
  # Build and Push to ACR
  build-and-push:
    name: Build & Push to ACR
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set_tag.outputs.image_tag }}
      short_sha: ${{ steps.set_tag.outputs.short_sha }}
      git_sha: ${{ github.sha }}

    steps:
      - name: Log context
        run: |
          echo "  Azure Container Apps Deployment"
          echo "  SHA:    ${{ github.sha }}"
          echo "  REF:    ${{ github.ref }}"
          echo "  EVENT:  ${{ github.event_name }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: 10

      - name: Install dependencies
        run: pnpm install

      - name: Run tests
        run: pnpm test

      - name: Build application
        run: pnpm build

      - name: Login to ACR
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Set image tag
        id: set_tag
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}" >> $GITHUB_OUTPUT
          echo "Using image tag: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${SHORT_SHA}"

      - name: Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=
            type=ref,event=branch
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          build-args: |
            GIT_SHA=${{ github.sha }}
            PLATFORM_VERSION=${{ github.ref_name }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    needs: build-and-push
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' || (github.event_name == 'workflow_dispatch' && inputs.environment == 'staging') }}
    environment:
      name: staging
      url: ${{ steps.get_url.outputs.app_url }}
    outputs:
      app_url: ${{ steps.get_url.outputs.app_url }}

    steps:
      - name: Validate environment variables
        run: |
          echo "=== Environment Variable Validation ==="
          echo "Target Resource Group: ${{ vars.AZURE_RESOURCE_GROUP }}"
          echo "Target Container App:  ${{ vars.CONTAINER_APP_NAME }}"
          echo "Target URL:            ${{ vars.STAGING_URL }}"
          echo ""
          
          # Fail-fast guardrails
          if [ -z "${{ vars.AZURE_RESOURCE_GROUP }}" ]; then
            echo "âŒ FATAL: vars.AZURE_RESOURCE_GROUP is not set in staging environment"
            echo "   Go to: Repository Settings â†’ Environments â†’ staging â†’ Add variable"
            exit 1
          fi
          
          if [ -z "${{ vars.CONTAINER_APP_NAME }}" ]; then
            echo "âŒ FATAL: vars.CONTAINER_APP_NAME is not set in staging environment"
            echo "   Go to: Repository Settings â†’ Environments â†’ staging â†’ Add variable"
            exit 1
          fi
          
          if [ -z "${{ vars.STAGING_URL }}" ]; then
            echo "âš ï¸ WARNING: vars.STAGING_URL is not set - will auto-detect from Azure"
          elif [[ ! "${{ vars.STAGING_URL }}" =~ ^https:// ]]; then
            echo "âŒ FATAL: vars.STAGING_URL must start with https://"
            exit 1
          fi
          
          echo "âœ… Environment variables validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure ACR credentials on Container App
        run: |
          echo "Configuring ACR registry credentials..."
          az containerapp registry set \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --server "${{ secrets.ACR_LOGIN_SERVER }}" \
            --username "${{ secrets.ACR_USERNAME }}" \
            --password "${{ secrets.ACR_PASSWORD }}"

      - name: Deploy to Container App (Staging)
        id: deploy
        run: |
          # Construct image tag here to avoid GitHub secret masking of job outputs
          IMAGE_TAG="${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.short_sha }}"
          echo "Deploying image: ${IMAGE_TAG}"
          az containerapp update \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --image "${IMAGE_TAG}"

      - name: Set environment variables
        run: |
          az containerapp update \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --set-env-vars \
              NODE_ENV=production \
              APP_ENV=staging \
              GIT_SHA="${{ github.sha }}" \
              PLATFORM_VERSION="${{ github.ref_name }}" \
              BUILD_TIME="${{ github.event.head_commit.timestamp }}" \
              STORAGE_PROVIDER="${{ vars.STORAGE_PROVIDER || 'azure' }}" \
              AZURE_STORAGE_CONTAINER_NAME="${{ vars.AZURE_STORAGE_CONTAINER_NAME || 'jobsheets-staging' }}" \
              ENABLE_PURGE_EXECUTION="${{ vars.ENABLE_PURGE_EXECUTION || 'false' }}" \
              ENABLE_SCHEDULER="${{ vars.ENABLE_SCHEDULER || 'false' }}"

      - name: Set secrets as environment variables
        run: |
          # Set storage connection string as a secret env var
          if [ -n "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "azure-storage-connection-string=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "AZURE_STORAGE_CONNECTION_STRING=secretref:azure-storage-connection-string"
          fi
          
          # Set database URL as a secret env var
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "database-url=${{ secrets.DATABASE_URL }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "DATABASE_URL=secretref:database-url"
          fi
          
          # Set AI API keys (Mistral OCR + Gemini Analysis)
          if [ -n "${{ secrets.MISTRAL_API_KEY }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "mistral-api-key=${{ secrets.MISTRAL_API_KEY }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "MISTRAL_API_KEY=secretref:mistral-api-key"
          fi
          
          if [ -n "${{ secrets.GEMINI_API_KEY }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "gemini-api-key=${{ secrets.GEMINI_API_KEY }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "GEMINI_API_KEY=secretref:gemini-api-key" \
                "ENABLE_GEMINI_INSIGHTS=true"
          fi

      - name: Get staging URL
        id: get_url
        run: |
          # Use vars.STAGING_URL if set, otherwise auto-detect from Azure
          if [ -n "${{ vars.STAGING_URL }}" ]; then
            APP_URL="${{ vars.STAGING_URL }}"
            echo "Using configured STAGING_URL: ${APP_URL}"
          else
            FQDN=$(az containerapp show \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --query properties.configuration.ingress.fqdn -o tsv)
            APP_URL="https://${FQDN}"
            echo "Auto-detected staging URL: ${APP_URL}"
          fi
          echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT

      - name: Wait for deployment
        run: |
          echo "Waiting 90 seconds for deployment to stabilize..."
          sleep 90

      - name: Smoke test staging
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Testing: $APP_URL"
          
          # Test healthz (required)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/healthz" --max-time 30)
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "âŒ /healthz returned $HTTP_CODE"
            curl -sS "$APP_URL/healthz" || true
            exit 1
          fi
          echo "âœ… /healthz returned 200"
          
          # Test readyz (REQUIRED - deployment fails if unhealthy)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/readyz" --max-time 30)
          READYZ_BODY=$(curl -sS "$APP_URL/readyz" --max-time 30)
          echo "ðŸ“‹ /readyz response:"
          echo "$READYZ_BODY" | jq . 2>/dev/null || echo "$READYZ_BODY"
          
          # Parse status from response
          READYZ_STATUS=$(echo "$READYZ_BODY" | jq -r '.status // "unknown"' 2>/dev/null || echo "unknown")
          
          if [[ "$HTTP_CODE" != "200" ]] || [[ "$READYZ_STATUS" != "ok" ]]; then
            echo ""
            echo "âŒ /readyz FAILED - deployment cannot proceed"
            echo "   HTTP Code: $HTTP_CODE"
            echo "   Status: $READYZ_STATUS"
            echo ""
            # Show individual check failures
            DB_STATUS=$(echo "$READYZ_BODY" | jq -r '.checks.database.status // "unknown"' 2>/dev/null)
            DB_ERROR=$(echo "$READYZ_BODY" | jq -r '.checks.database.error // "none"' 2>/dev/null)
            STORAGE_STATUS=$(echo "$READYZ_BODY" | jq -r '.checks.storage.status // "unknown"' 2>/dev/null)
            STORAGE_ERROR=$(echo "$READYZ_BODY" | jq -r '.checks.storage.error // "none"' 2>/dev/null)
            
            echo "   Database:  $DB_STATUS (error: $DB_ERROR)"
            echo "   Storage:   $STORAGE_STATUS (error: $STORAGE_ERROR)"
            echo ""
            echo "Fix: Check Container App env vars and secrets configuration"
            exit 1
          fi
          echo "âœ… /readyz returned 200 with status: ok"
          
          # Test metrics (required per ADR-003)
          HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/metrics" --max-time 30)
          if [[ "$HTTP_CODE" != "200" ]]; then
            echo "âŒ /metrics returned $HTTP_CODE"
            exit 1
          fi
          # Verify it's Prometheus format, not HTML
          METRICS_SAMPLE=$(curl -sS "$APP_URL/metrics" --max-time 30 | head -5)
          if echo "$METRICS_SAMPLE" | grep -q "^# HELP"; then
            echo "âœ… /metrics returned 200 with Prometheus format"
          else
            echo "âŒ /metrics returned HTML instead of Prometheus format"
            exit 1
          fi

  # Verify Staging (Full Release Verification)
  verify-staging:
    name: Verify Staging
    needs: [build-and-push, deploy-staging]
    runs-on: ubuntu-latest
    if: ${{ !inputs.skip_verification }}
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate environment variables
        run: |
          echo "=== Staging Verification Environment Check ==="
          echo "Target Resource Group: ${{ vars.AZURE_RESOURCE_GROUP }}"
          echo "Target Container App:  ${{ vars.CONTAINER_APP_NAME }}"
          echo "Target URL:            ${{ vars.STAGING_URL }}"
          
          if [ -z "${{ vars.AZURE_RESOURCE_GROUP }}" ] || [ -z "${{ vars.CONTAINER_APP_NAME }}" ]; then
            echo "âŒ FATAL: Environment variables not set"
            exit 1
          fi
          echo "âœ… Environment validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get staging URL
        id: get_url
        run: |
          # Use vars.STAGING_URL if set, otherwise auto-detect
          if [ -n "${{ vars.STAGING_URL }}" ]; then
            STAGING_URL="${{ vars.STAGING_URL }}"
          else
            FQDN=$(az containerapp show \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --query properties.configuration.ingress.fqdn -o tsv)
            STAGING_URL="https://${FQDN}"
          fi
          echo "staging_url=${STAGING_URL}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Resolved staging URL: ${STAGING_URL}"

      - name: Run release verification
        env:
          STAGING_URL: ${{ steps.get_url.outputs.staging_url }}
          EXPECTED_SHA: ${{ github.sha }}
        run: |
          if [ -z "$STAGING_URL" ]; then
            echo "âŒ ERROR: Could not resolve staging URL"
            exit 1
          fi
          echo "ðŸ”— Using STAGING_URL: $STAGING_URL"
          
          chmod +x scripts/release/smoke-check.sh
          chmod +x scripts/release/monitor-snapshot.sh
          
          # Run smoke checks (soft mode for staging)
          ./scripts/release/smoke-check.sh "$STAGING_URL" "$EXPECTED_SHA" "soft"
          
          # Run monitoring snapshot
          ENVIRONMENT=staging HEALTH_ONLY=false \
            ./scripts/release/monitor-snapshot.sh "$STAGING_URL" "soft" "false"

      - name: Capture endpoint evidence
        id: evidence
        run: |
          STAGING_URL="${{ steps.get_url.outputs.staging_url }}"
          mkdir -p logs/release/evidence
          
          echo "Capturing endpoint evidence..."
          curl -sS "$STAGING_URL/healthz" > logs/release/evidence/healthz.json || true
          curl -sS "$STAGING_URL/readyz" > logs/release/evidence/readyz.json || true
          curl -sS "$STAGING_URL/metrics" | head -50 > logs/release/evidence/metrics.txt || true
          curl -sS "$STAGING_URL/api/trpc/system.version" > logs/release/evidence/version.json || true
          
          # Verify SHA match
          DEPLOYED_SHA=$(cat logs/release/evidence/version.json | jq -r '.result.data.gitSha // empty' 2>/dev/null || echo "")
          if [ -n "$DEPLOYED_SHA" ]; then
            echo "Deployed SHA: $DEPLOYED_SHA"
            echo "Expected SHA: ${{ github.sha }}"
            if [ "$DEPLOYED_SHA" != "${{ github.sha }}" ]; then
              echo "âš ï¸ SHA mismatch - may be a cached response"
            else
              echo "âœ… SHA verified"
            fi
          fi

      - name: Verify static asset serving (cache headers)
        run: |
          STAGING_URL="${{ steps.get_url.outputs.staging_url }}"
          mkdir -p logs/release/evidence
          
          echo "=== STAGE D: Static Asset Verification ==="
          
          # 1. Verify manifest.webmanifest is accessible with correct content-type
          echo "Testing manifest.webmanifest..."
          MANIFEST_HEADERS=$(curl -sI "$STAGING_URL/manifest.webmanifest" --max-time 10)
          MANIFEST_STATUS=$(echo "$MANIFEST_HEADERS" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          MANIFEST_TYPE=$(echo "$MANIFEST_HEADERS" | grep -i "^content-type:" | cut -d: -f2 | tr -d ' \r')
          
          if [[ "$MANIFEST_STATUS" != "200" ]]; then
            echo "âŒ manifest.webmanifest returned $MANIFEST_STATUS (expected 200)"
            echo "$MANIFEST_HEADERS"
            exit 1
          fi
          echo "âœ… manifest.webmanifest: $MANIFEST_STATUS, $MANIFEST_TYPE"
          
          # 2. Verify assets/*.js chunks are accessible with correct cache headers
          echo "Testing assets JS chunk..."
          # Get any asset from manifest or build
          ASSET_PATH=$(curl -sS "$STAGING_URL/manifest.webmanifest" --max-time 10 2>/dev/null | grep -o '"src":"[^"]*"' | head -1 | cut -d'"' -f4 || echo "")
          
          # If no asset in manifest, try to find from index.html
          if [ -z "$ASSET_PATH" ]; then
            # Since we need auth for index.html, test a known static path pattern
            ASSET_PATH="sw.js"
          fi
          
          ASSET_HEADERS=$(curl -sI "$STAGING_URL/$ASSET_PATH" --max-time 10)
          ASSET_STATUS=$(echo "$ASSET_HEADERS" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          ASSET_CACHE=$(echo "$ASSET_HEADERS" | grep -i "^cache-control:" | cut -d: -f2 | tr -d '\r')
          
          if [[ "$ASSET_STATUS" != "200" ]]; then
            echo "âŒ /$ASSET_PATH returned $ASSET_STATUS (expected 200)"
            echo "   Static assets may be blocked by Azure Easy Auth excludedPaths"
            echo "$ASSET_HEADERS"
            # Soft fail for staging
            echo "âš ï¸ Static asset check failed (soft mode)"
          else
            echo "âœ… /$ASSET_PATH: $ASSET_STATUS, Cache-Control:$ASSET_CACHE"
          fi
          
          # 3. Save headers evidence
          echo "$MANIFEST_HEADERS" > logs/release/evidence/manifest-headers.txt
          echo "$ASSET_HEADERS" > logs/release/evidence/asset-headers.txt
          
          echo "=== Static asset verification complete ==="

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: staging-verification-${{ github.run_id }}
          path: logs/release/
          retention-days: 30

  # Deploy to Production (Manual Trigger Only)
  deploy-production:
    name: Deploy to Production
    needs: [build-and-push, verify-staging]
    runs-on: ubuntu-latest
    # Allow production deploy when staging is skipped (direct production trigger) or when it passed
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.environment == 'production' && !failure() && !cancelled() }}
    environment:
      name: production
      url: ${{ steps.get_url.outputs.app_url }}
    outputs:
      app_url: ${{ steps.get_url.outputs.app_url }}

    steps:
      - name: Validate environment variables
        run: |
          echo "=== Environment Variable Validation (PRODUCTION) ==="
          echo "Target Resource Group: ${{ vars.AZURE_RESOURCE_GROUP }}"
          echo "Target Container App:  ${{ vars.CONTAINER_APP_NAME }}"
          echo "Target URL:            ${{ vars.PRODUCTION_URL }}"
          echo ""
          
          # Fail-fast guardrails (STRICT for production)
          if [ -z "${{ vars.AZURE_RESOURCE_GROUP }}" ]; then
            echo "âŒ FATAL: vars.AZURE_RESOURCE_GROUP is not set in production environment"
            echo "   Go to: Repository Settings â†’ Environments â†’ production â†’ Add variable"
            exit 1
          fi
          
          if [ -z "${{ vars.CONTAINER_APP_NAME }}" ]; then
            echo "âŒ FATAL: vars.CONTAINER_APP_NAME is not set in production environment"
            echo "   Go to: Repository Settings â†’ Environments â†’ production â†’ Add variable"
            exit 1
          fi
          
          if [ -z "${{ vars.PRODUCTION_URL }}" ]; then
            echo "âš ï¸ WARNING: vars.PRODUCTION_URL is not set - will auto-detect from Azure"
          elif [[ ! "${{ vars.PRODUCTION_URL }}" =~ ^https:// ]]; then
            echo "âŒ FATAL: vars.PRODUCTION_URL must start with https://"
            exit 1
          fi
          
          echo "âœ… Environment variables validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Configure ACR credentials on Container App
        run: |
          echo "Configuring ACR registry credentials..."
          az containerapp registry set \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --server "${{ secrets.ACR_LOGIN_SERVER }}" \
            --username "${{ secrets.ACR_USERNAME }}" \
            --password "${{ secrets.ACR_PASSWORD }}"

      - name: Deploy to Container App (Production)
        id: deploy
        run: |
          # Construct image tag here to avoid GitHub secret masking of job outputs
          IMAGE_TAG="${{ secrets.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${{ needs.build-and-push.outputs.short_sha }}"
          echo "Deploying image: ${IMAGE_TAG}"
          az containerapp update \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --image "${IMAGE_TAG}"

      - name: Set environment variables
        run: |
          az containerapp update \
            --name "${{ vars.CONTAINER_APP_NAME }}" \
            --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
            --set-env-vars \
              NODE_ENV=production \
              APP_ENV=production \
              GIT_SHA="${{ github.sha }}" \
              PLATFORM_VERSION="${{ github.ref_name }}" \
              BUILD_TIME="${{ github.event.head_commit.timestamp }}" \
              STORAGE_PROVIDER="${{ vars.STORAGE_PROVIDER || 'azure' }}" \
              AZURE_STORAGE_CONTAINER_NAME="${{ vars.AZURE_STORAGE_CONTAINER_NAME || 'jobsheets' }}" \
              ENABLE_PURGE_EXECUTION="${{ vars.ENABLE_PURGE_EXECUTION || 'false' }}" \
              ENABLE_SCHEDULER="${{ vars.ENABLE_SCHEDULER || 'false' }}"

      - name: Set secrets as environment variables
        run: |
          # Set storage connection string as a secret env var
          if [ -n "${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "azure-storage-connection-string=${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "AZURE_STORAGE_CONNECTION_STRING=secretref:azure-storage-connection-string"
          fi
          
          # Set database URL as a secret env var
          if [ -n "${{ secrets.DATABASE_URL }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "database-url=${{ secrets.DATABASE_URL }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "DATABASE_URL=secretref:database-url"
          fi
          
          # Set AI API keys (Mistral OCR + Gemini Analysis)
          if [ -n "${{ secrets.MISTRAL_API_KEY }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "mistral-api-key=${{ secrets.MISTRAL_API_KEY }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "MISTRAL_API_KEY=secretref:mistral-api-key"
          fi
          
          if [ -n "${{ secrets.GEMINI_API_KEY }}" ]; then
            az containerapp secret set \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --secrets "gemini-api-key=${{ secrets.GEMINI_API_KEY }}"
            
            az containerapp update \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --set-env-vars "GEMINI_API_KEY=secretref:gemini-api-key" \
                "ENABLE_GEMINI_INSIGHTS=true"
          fi

      - name: Get production URL
        id: get_url
        run: |
          # Use vars.PRODUCTION_URL if set, otherwise auto-detect from Azure
          if [ -n "${{ vars.PRODUCTION_URL }}" ]; then
            APP_URL="${{ vars.PRODUCTION_URL }}"
            echo "Using configured PRODUCTION_URL: ${APP_URL}"
          else
            FQDN=$(az containerapp show \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --query properties.configuration.ingress.fqdn -o tsv)
            APP_URL="https://${FQDN}"
            echo "Auto-detected production URL: ${APP_URL}"
          fi
          echo "app_url=${APP_URL}" >> $GITHUB_OUTPUT

      - name: Wait for deployment
        run: |
          echo "Waiting 90 seconds for deployment to stabilize..."
          sleep 90

      - name: Smoke test production (STRICT)
        run: |
          APP_URL="${{ steps.get_url.outputs.app_url }}"
          echo "Testing: $APP_URL (STRICT mode - all checks must pass)"
          
          # Test all endpoints - ALL must pass for production
          for ENDPOINT in healthz readyz metrics; do
            HTTP_CODE=$(curl -sS -o /dev/null -w "%{http_code}" "$APP_URL/$ENDPOINT" --max-time 30)
            if [[ "$HTTP_CODE" != "200" ]]; then
              echo "âŒ /$ENDPOINT returned $HTTP_CODE"
              curl -sS "$APP_URL/$ENDPOINT" || true
              exit 1
            fi
            echo "âœ… /$ENDPOINT returned 200"
          done
          
          # Verify metrics is Prometheus format (ADR-003)
          METRICS_SAMPLE=$(curl -sS "$APP_URL/metrics" --max-time 30 | head -5)
          if ! echo "$METRICS_SAMPLE" | grep -q "^# HELP"; then
            echo "âŒ /metrics returned HTML instead of Prometheus format"
            exit 1
          fi
          echo "âœ… /metrics is valid Prometheus format"

  # Verify Production (Strict Mode)
  verify-production:
    name: Verify Production
    needs: [build-and-push, deploy-production]
    runs-on: ubuntu-latest
    # Allow verification when deploy succeeds (using needs context to check deploy-production result)
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.environment == 'production' && !inputs.skip_verification && needs.deploy-production.result == 'success' }}
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate environment variables
        run: |
          echo "=== Production Verification Environment Check ==="
          echo "Target Resource Group: ${{ vars.AZURE_RESOURCE_GROUP }}"
          echo "Target Container App:  ${{ vars.CONTAINER_APP_NAME }}"
          echo "Target URL:            ${{ vars.PRODUCTION_URL }}"
          
          if [ -z "${{ vars.AZURE_RESOURCE_GROUP }}" ] || [ -z "${{ vars.CONTAINER_APP_NAME }}" ]; then
            echo "âŒ FATAL: Environment variables not set"
            exit 1
          fi
          echo "âœ… Environment validated"

      - name: Login to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get production URL
        id: get_url
        run: |
          # Use vars.PRODUCTION_URL if set, otherwise auto-detect
          if [ -n "${{ vars.PRODUCTION_URL }}" ]; then
            PRODUCTION_URL="${{ vars.PRODUCTION_URL }}"
          else
            FQDN=$(az containerapp show \
              --name "${{ vars.CONTAINER_APP_NAME }}" \
              --resource-group "${{ vars.AZURE_RESOURCE_GROUP }}" \
              --query properties.configuration.ingress.fqdn -o tsv)
            PRODUCTION_URL="https://${FQDN}"
          fi
          echo "production_url=${PRODUCTION_URL}" >> $GITHUB_OUTPUT
          echo "ðŸ”— Resolved production URL: ${PRODUCTION_URL}"

      - name: Run release verification (STRICT)
        env:
          PRODUCTION_URL: ${{ steps.get_url.outputs.production_url }}
          EXPECTED_SHA: ${{ github.sha }}
        run: |
          if [ -z "$PRODUCTION_URL" ]; then
            echo "âŒ ERROR: Could not resolve production URL"
            exit 1
          fi
          echo "ðŸ”— Using PRODUCTION_URL: $PRODUCTION_URL"
          
          chmod +x scripts/release/smoke-check.sh
          chmod +x scripts/release/monitor-snapshot.sh
          
          # Run smoke checks (STRICT mode for production)
          ./scripts/release/smoke-check.sh "$PRODUCTION_URL" "$EXPECTED_SHA" "strict"
          
          # Run monitoring snapshot (STRICT mode, metrics REQUIRED)
          ENVIRONMENT=production HEALTH_ONLY=false \
            ./scripts/release/monitor-snapshot.sh "$PRODUCTION_URL" "strict" "false"

      - name: Capture endpoint evidence
        id: evidence
        run: |
          PRODUCTION_URL="${{ steps.get_url.outputs.production_url }}"
          mkdir -p logs/release/evidence
          
          echo "Capturing endpoint evidence..."
          curl -sS "$PRODUCTION_URL/healthz" > logs/release/evidence/healthz.json || true
          curl -sS "$PRODUCTION_URL/readyz" > logs/release/evidence/readyz.json || true
          curl -sS "$PRODUCTION_URL/metrics" | head -50 > logs/release/evidence/metrics.txt || true
          curl -sS "$PRODUCTION_URL/api/trpc/system.version" > logs/release/evidence/version.json || true
          
          # Verify SHA match (STRICT for production)
          DEPLOYED_SHA=$(cat logs/release/evidence/version.json | jq -r '.result.data.gitSha // empty' 2>/dev/null || echo "")
          if [ -z "$DEPLOYED_SHA" ]; then
            echo "âŒ FATAL: Could not retrieve deployed SHA"
            exit 1
          fi
          
          echo "Deployed SHA: $DEPLOYED_SHA"
          echo "Expected SHA: ${{ github.sha }}"
          
          if [ "$DEPLOYED_SHA" != "${{ github.sha }}" ]; then
            echo "âŒ FATAL: SHA mismatch - deployment verification failed"
            exit 1
          fi
          echo "âœ… SHA verified - deployment confirmed"

      - name: Verify static asset serving (STRICT - production)
        run: |
          PRODUCTION_URL="${{ steps.get_url.outputs.production_url }}"
          mkdir -p logs/release/evidence
          
          echo "=== STAGE D: Static Asset Verification (STRICT) ==="
          
          # 1. Verify manifest.webmanifest is accessible (MUST pass)
          echo "Testing manifest.webmanifest..."
          MANIFEST_HEADERS=$(curl -sI "$PRODUCTION_URL/manifest.webmanifest" --max-time 10)
          MANIFEST_STATUS=$(echo "$MANIFEST_HEADERS" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          MANIFEST_TYPE=$(echo "$MANIFEST_HEADERS" | grep -i "^content-type:" | cut -d: -f2 | tr -d ' \r')
          
          if [[ "$MANIFEST_STATUS" != "200" ]]; then
            echo "âŒ FATAL: manifest.webmanifest returned $MANIFEST_STATUS (expected 200)"
            echo "   This indicates Azure Easy Auth excludedPaths is misconfigured"
            echo "$MANIFEST_HEADERS"
            exit 1
          fi
          echo "âœ… manifest.webmanifest: $MANIFEST_STATUS, $MANIFEST_TYPE"
          
          # 2. Verify sw.js (service worker) is accessible
          echo "Testing service worker..."
          SW_HEADERS=$(curl -sI "$PRODUCTION_URL/sw.js" --max-time 10)
          SW_STATUS=$(echo "$SW_HEADERS" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          SW_CACHE=$(echo "$SW_HEADERS" | grep -i "^cache-control:" | cut -d: -f2 | tr -d '\r')
          
          if [[ "$SW_STATUS" != "200" ]]; then
            echo "âŒ FATAL: sw.js returned $SW_STATUS (expected 200)"
            echo "$SW_HEADERS"
            exit 1
          fi
          echo "âœ… sw.js: $SW_STATUS, Cache-Control:$SW_CACHE"
          
          # 3. Verify images are accessible
          echo "Testing images..."
          IMG_HEADERS=$(curl -sI "$PRODUCTION_URL/images/audit-icon.png" --max-time 10)
          IMG_STATUS=$(echo "$IMG_HEADERS" | grep -i "^HTTP" | tail -1 | awk '{print $2}')
          IMG_TYPE=$(echo "$IMG_HEADERS" | grep -i "^content-type:" | cut -d: -f2 | tr -d ' \r')
          
          if [[ "$IMG_STATUS" != "200" ]]; then
            echo "âŒ FATAL: images/audit-icon.png returned $IMG_STATUS (expected 200)"
            echo "$IMG_HEADERS"
            exit 1
          fi
          if [[ "$IMG_TYPE" != *"image/"* ]]; then
            echo "âŒ FATAL: Image returned wrong content-type: $IMG_TYPE"
            exit 1
          fi
          echo "âœ… images/audit-icon.png: $IMG_STATUS, $IMG_TYPE"
          
          # Save headers evidence
          echo "$MANIFEST_HEADERS" > logs/release/evidence/manifest-headers.txt
          echo "$SW_HEADERS" > logs/release/evidence/sw-headers.txt
          echo "$IMG_HEADERS" > logs/release/evidence/image-headers.txt
          
          echo "=== Static asset verification PASSED (STRICT) ==="

      - name: Upload verification artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-verification-${{ github.run_id }}
          path: logs/release/
          retention-days: 30

      - name: Generate deployment summary
        run: |
          {
            echo "# Production Deployment Complete âœ…"
            echo ""
            echo "| Field | Value |"
            echo "|-------|-------|"
            echo "| SHA | ${{ github.sha }} |"
            echo "| Resource Group | ${{ vars.AZURE_RESOURCE_GROUP }} |"
            echo "| Container App | ${{ vars.CONTAINER_APP_NAME }} |"
            echo "| URL | ${{ needs.deploy-production.outputs.app_url }} |"
            echo "| Verification | STRICT mode PASSED |"
          } >> "$GITHUB_STEP_SUMMARY"
